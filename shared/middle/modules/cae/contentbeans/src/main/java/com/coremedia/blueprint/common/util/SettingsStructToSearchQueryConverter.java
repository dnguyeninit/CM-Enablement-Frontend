package com.coremedia.blueprint.common.util;

import com.coremedia.blueprint.base.settings.SettingsService;
import com.coremedia.blueprint.cae.search.Condition;
import com.coremedia.blueprint.cae.search.SearchConstants;
import com.coremedia.blueprint.cae.search.SearchQueryBean;
import com.coremedia.blueprint.cae.search.Value;
import com.coremedia.blueprint.cae.search.solr.SolrQueryBuilder;
import com.coremedia.blueprint.common.contentbeans.CMLocTaxonomy;
import com.coremedia.blueprint.common.contentbeans.CMNavigation;
import com.coremedia.blueprint.common.contentbeans.CMPerson;
import com.coremedia.blueprint.common.contentbeans.CMQueryList;
import com.coremedia.blueprint.common.contentbeans.CMTaxonomy;
import com.coremedia.cap.common.IdHelper;
import com.coremedia.cap.content.Content;
import com.coremedia.cap.content.ContentRepository;
import com.coremedia.cap.multisite.Site;
import com.coremedia.cap.multisite.SitesService;
import com.coremedia.cap.struct.Struct;
import com.coremedia.cap.util.CapStructUtil;
import com.coremedia.objectserver.beans.ContentBean;
import com.coremedia.objectserver.beans.ContentBeanFactory;
import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.coremedia.blueprint.base.querylist.FilterQueryHelper.getModificationDate;
import static com.coremedia.blueprint.base.querylist.FilterQueryHelper.getSortFields;
import static java.util.Collections.singletonList;

/**
 * Uses the local settings struct generated by the Studio
 * query editor and converts it to a SearchQuery object that
 * is used e.g. for CMQueryList content.
 */
@DefaultAnnotation(NonNull.class)
public class SettingsStructToSearchQueryConverter {
  private static final Logger LOG = LoggerFactory.getLogger(SettingsStructToSearchQueryConverter.class);

  // An actual limit for "unlimited" searches
  private static final int BIG_LIMIT = 1000;

  //See RequestAttributeConstants
  private static final String REQUEST_ATTR_NAME_PAGE_MODEL = "cmpage_model";

  private static final String KEY_SUBJECT_TAXONOMY = SearchConstants.FIELDS.SUBJECT_TAXONOMY.toString();
  private static final String KEY_LOCATION_TAXONOMY = SearchConstants.FIELDS.LOCATION_TAXONOMY.toString();
  private static final String KEY_MODIFICATION_DATE = SearchConstants.FIELDS.MODIFICATION_DATE.toString();
  private static final String KEY_DOCUMENT_TYPE = SearchConstants.FIELDS.DOCUMENTTYPE.toString();

  private static final String KEY_CONTEXT_TAXONOMIES = "contextTaxonomies";

  private static final String KEY_DOCUMENTS = "documents";
  private static final String KEY_AUTHORS = "authors";
  private static final String KEY_LIMIT = "limit";
  private static final String KEY_ORDER = "order";

  private static final String KEY_FQ = "fq";

  private final CMQueryList queryList;
  private final SitesService sitesService;
  private final SettingsService settingsService;
  private final ContentBeanFactory contentBeanFactory;
  private final ContentRepository contentRepository;

  /**
   * Ignore the limit setting.
   * <p>
   * In pagination contexts it denotes the number of items per page, rather
   * than of the complete result.  We use the same setting for the sake of UI
   * convenience, so we must take care for the logic here.
   */
  private final boolean unlimited;

  public SettingsStructToSearchQueryConverter(CMQueryList queryList,
                                              SitesService sitesService,
                                              SettingsService settingsService,
                                              ContentRepository contentRepository,
                                              ContentBeanFactory contentBeanFactory) {
    this(queryList, sitesService, settingsService, contentRepository, contentBeanFactory, false);
  }

  public SettingsStructToSearchQueryConverter(CMQueryList queryList,
                                              SitesService sitesService,
                                              SettingsService settingsService,
                                              ContentRepository contentRepository,
                                              ContentBeanFactory contentBeanFactory,
                                              boolean unlimited) {
    this.queryList = queryList;
    this.sitesService = sitesService;
    this.settingsService = settingsService;
    this.contentBeanFactory = contentBeanFactory;
    this.contentRepository = contentRepository;
    this.unlimited = unlimited;
  }

  /**
   * Reads the solr search settings from the local settings properties.
   * The struct xml has been generated by the dynamic query editor in the Studio.
   *
   * @return The SearchQueryBean.
   */
  public SearchQueryBean convert() {
    SearchQueryBean searchQuery = new SearchQueryBean();
    searchQuery.setQuery(SolrQueryBuilder.ANY_FIELD_ANY_VALUE);

    // prevent cross site searches
    sitesService.getContentSiteAspect(queryList.getContent())
      .findSite()
      .map(Site::getSiteRootDocument)
      .ifPresent(root -> searchQuery.setContext(String.valueOf(IdHelper.parseContentId(root.getId()))));

    if (unlimited) {
      searchQuery.setLimit(BIG_LIMIT);
    } else {
      applyLimit(searchQuery);
    }
    applyOrder(searchQuery);

    Struct fqStruct = settingsService.setting(KEY_FQ, Struct.class, queryList.getContent());
    if (fqStruct != null) {
      applyDocumentType(fqStruct, searchQuery);
      applyContexts(fqStruct, searchQuery);
      applyAuthors(fqStruct, searchQuery);
      applyKeywords(fqStruct, KEY_SUBJECT_TAXONOMY, SearchConstants.FIELDS.SUBJECT_TAXONOMY, searchQuery);
      applyKeywords(fqStruct, KEY_LOCATION_TAXONOMY, SearchConstants.FIELDS.LOCATION_TAXONOMY, searchQuery);
      applyContextKeywords(fqStruct, KEY_CONTEXT_TAXONOMIES, searchQuery);
      applyModificationDate(fqStruct, searchQuery);
      applyCustomFilter(fqStruct, searchQuery);
    }

    return searchQuery;
  }

  /**
   * Applies the order by param to the query if set.
   * @param searchQuery the SearchQueryBean
   */
  protected void applyOrder(SearchQueryBean searchQuery) {
    List<String> searchConstants = Stream.of(SearchConstants.FIELDS.values()).map(SearchConstants.FIELDS::toString).collect(Collectors.toList());
    String orderBy = settingsService.setting(KEY_ORDER, String.class, queryList.getContent());
    List<String> sortFields = getSortFields(orderBy, searchConstants);
    if (!sortFields.isEmpty()) {
      searchQuery.setSortFields(sortFields);
    }
  }

  /**
   * Applies the number of items.
   *
   * @param searchQuery the SearchQueryBean
   */

  protected void applyLimit(SearchQueryBean searchQuery) {
    Integer limit = settingsService.setting(KEY_LIMIT, Integer.class, queryList.getContent());
    if (limit!=null && limit>0) {
      searchQuery.setLimit(limit);
    }
  }

  /**
   * Applies the publication date to the query.
   * Be aware that the publication date can be entered without formatting
   * using the expert mode of the Studio!
   *
   * @param fqStruct the filter query struct
   * @param searchQuery the SearchQueryBean
   */
  protected void applyModificationDate(Struct fqStruct, SearchQueryBean searchQuery) {
    String dateString = CapStructUtil.getString(fqStruct, KEY_MODIFICATION_DATE);
    Optional<String> formattedString = getModificationDate(dateString);
    formattedString.ifPresent(formatted -> searchQuery.addFilter(Condition.greaterThan(SearchConstants.FIELDS.MODIFICATION_DATE, Value.exactly(formatted))));
  }

  /**
   * Takes the documents from the query (channel documents)
   * add them as navigation criteria to the query.
   *
   * @param fqStruct the filter query struct
   * @param searchQuery the SearchQueryBean
   */
  protected void applyContexts(Struct fqStruct, SearchQueryBean searchQuery) {
    List<Content> docs = CapStructUtil.getLinks(fqStruct, KEY_DOCUMENTS);
    if (!docs.isEmpty()) {
      List<CMNavigation> navigations = contentBeanFactory.createBeansFor(docs, CMNavigation.class);
      List<String> convertedNavigation = ContentBeanSolrSearchFormatHelper.cmNavigationsToId(navigations);
      searchQuery.addFilter(Condition.is(
              SearchConstants.FIELDS.NAVIGATION_PATHS, Value.anyOf(convertedNavigation)));
    }
  }

  /**
   * Takes the authors from the query (person documents) and
   * add them as authors criteria to the query.
   *
   * @param fqStruct the filter query struct
   * @param searchQuery the SearchQueryBean
   */
  protected void applyAuthors(Struct fqStruct, SearchQueryBean searchQuery) {
    List<Content> personContents = CapStructUtil.getLinks(fqStruct, KEY_AUTHORS);
    if (!personContents.isEmpty()) {
      List<CMPerson> personBeans = contentBeanFactory.createBeansFor(personContents, CMPerson.class);
      List<String> personIds = ContentBeanSolrSearchFormatHelper.cmObjectsToIds(personBeans);
      searchQuery.addFilter(Condition.is(
              SearchConstants.FIELDS.AUTHORS, Value.anyOf(personIds)));
    }
  }


  /**
   * Parses the documents types, retrieves the concrete instances from
   * the repository and adds them to the query list.
   *
   * @param fqStruct the filter query struct
   * @param searchQuery the SearchQueryBean
   */
  protected void applyDocumentType(Struct fqStruct, SearchQueryBean searchQuery) {
    String docTypes = CapStructUtil.getString(fqStruct, KEY_DOCUMENT_TYPE);
    SearchQueryUtil.addDocumentTypeFilter(searchQuery, docTypes, contentRepository);
  }

  /**
   * Parsing keywords and applying them to the query.
   * @param  fqStruct the filter query struct
   * @param fqId  the struct field used to load the selected keywords
   * @param field the solr field used to store the information
   * @param searchQuery the SearchQueryBean
   */
  protected void applyKeywords(Struct fqStruct, String fqId, SearchConstants.FIELDS field, SearchQueryBean searchQuery) {
    List<Content> docs = CapStructUtil.getLinks(fqStruct, fqId);
    if (!docs.isEmpty()) {
      List<CMTaxonomy> taxonomies = contentBeanFactory.createBeansFor(docs, CMTaxonomy.class);
      List<String> taxonomyIds = ContentBeanSolrSearchFormatHelper.cmObjectsToIds(taxonomies);
      searchQuery.addFilter(Condition.is(field, Value.anyOf(taxonomyIds)));
    }
  }


  /**
   * Parsing related keywords and applying them to the query.
   *
   * @param fqStruct the filter query struct
   * @param fqId  the struct field used to load the selected keywords
   * @param searchQuery the SearchQueryBean
   */
  protected void applyContextKeywords(Struct fqStruct, String fqId, SearchQueryBean searchQuery) {
    boolean useContextTaxonomies = CapStructUtil.getBoolean(fqStruct, fqId);
    if (useContextTaxonomies) {
      Content taxonomy = getCurrentTaxonomy().orElse(null);
      if (taxonomy!=null) {
        LOG.debug("Found taxonomy {} in the request, use this for the CMQueryList as context", taxonomy);
        String id = String.valueOf(IdHelper.parseContentId(taxonomy.getId()));
        if(taxonomy.getType().isSubtypeOf(CMLocTaxonomy.NAME)) {
          searchQuery.addFilter(Condition.is(SearchConstants.FIELDS.LOCATION_TAXONOMY, Value.anyOf(singletonList(id))));
        } else  {
          searchQuery.addFilter(Condition.is(SearchConstants.FIELDS.SUBJECT_TAXONOMY, Value.anyOf(singletonList(id))));
        }
      }
    }
  }


  /**
   * Apply a custom filter to the search query.
   * Override this method to apply a custom filter to the searchQuery.
   * @param fqStruct the filter query struct
   * @param searchQuery the SearchQueryBean
   */
  protected void applyCustomFilter(Struct fqStruct, SearchQueryBean searchQuery) {
    // override to apply a custom filter to the search query
  }

  private Optional<Content> getCurrentTaxonomy() {
    Optional<ContentBean> taxonomyBean = ContextAttributes
      .findRequestAttribute(REQUEST_ATTR_NAME_PAGE_MODEL, ContentBean.class);
    Optional<Content> content = taxonomyBean
      .map(ContentBean::getContent);
    if (!content.isPresent()) {
      content = ContextAttributes.findSessionAttribute(REQUEST_ATTR_NAME_PAGE_MODEL, String.class)
        .map(id -> contentRepository.getContent(id));
    }
    return content
      .filter(c -> c.getType().isSubtypeOf(CMTaxonomy.NAME));
  }
}
